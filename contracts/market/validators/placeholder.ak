use aiken/collection/list
use cardano/address.{VerificationKey}
use cardano/assets
use cardano/transaction.{OutputReference, Transaction}

pub type MarketDatum {
  price: Int,
  seller: ByteArray,
}

pub type MarketAction {
  MBuy
  MEdit { price: Int }
  MDelist
}

validator placeholder {
  spend(
    datum: Option<MarketDatum>,
    redeemer: MarketAction,
    utxo: OutputReference,
    tx: Transaction,
  ) {
    expect Some(d) = datum
    when redeemer is {
      MBuy -> {
        //output to seller address
        expect Some(payment) =
          list.find(
            tx.outputs,
            fn(output) {
              output.address.payment_credential == VerificationKey(d.seller)
            },
          )
        //payment value is correct
        assets.lovelace_of(payment.value) == d.price
      }
      MEdit { price } -> {
        // (?) si editamos el precio, necesitamos gastar ese UTXO
        // es decir quitamos el activo del market, y volvemos a introducirlo al market
        expect Some(own_input) = list.find(tx.inputs, fn(input){ input.output_reference = utxo })
        let own_hash = own_input.output.address.payment_credential
        // script output has same value as input
        expect Some(own_output) = list.find(tx.outputs, fn(output){ output.address.payment_credential == own_hash && output.value == own_input.output.value })
        expect InlineDatum(datum) = own_output.datum
        expect newDatum : MarketDatum = datum
        and {
          newDatum.seller == d.seller,
          newDatum.price == price,
          list.has(tx.extra_signatories, d.seller),
        }
      }
      MDelist -> list.has(tx.extra_signatories, d.seller)
    }
  }

  else(_) {
    fail
  }
}
